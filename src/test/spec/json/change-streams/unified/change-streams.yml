description: "change-streams"
schemaVersion: "1.0"
createEntities:
  - client:
      id: &client0 client0
      observeEvents: [ commandStartedEvent ]
      ignoreCommandMonitoringEvents: [ killCursors ]
  - client:
      id: &globalClient globalClient
      useMultipleMongoses: false
  - database:
      id: &database0 database0
      client: *client0
      databaseName: *database0
  - collection:
      id: &collection0 collection0
      database: *database0
      collectionName: *collection0
  - database:
      id: &globalDatabase0 globalDatabase0
      client: *globalClient
      databaseName: *database0
  - collection:
      id: &globalCollection0 globalCollection0
      database: *globalDatabase0
      collectionName: *collection0

initialData:
  - collectionName: *collection0
    databaseName: *database0
    documents: []
tests:
  - description: "Test array truncation"
    runOnRequirements:
      - minServerVersion: "4.7"
        topologies: [replicaset]
    operations:
      - name: insertOne
        object: *collection0
        arguments:
          document: {
            "_id": 1,
            "a": 1,
            "array": ["foo", {"a": "bar"}, 1, 2, 3]
          }
      - name: createChangeStream
        object: *collection0
        arguments:
          pipeline: []
        saveResultAsEntity: &changeStream0 changeStream0
      - name: updateOne
        object: *collection0
        arguments:
          filter: {
            "_id": 1
          }
          update: [
            {
              "$set": {
                "array": ["foo", {"a": "bar"}]
              }
            }
          ]
      - name: iterateUntilDocumentOrError
        object: *changeStream0
        expectResult: {
          "operationType": "update",
          "ns": {
            "db": "database0",
            "coll": "collection0"
          },
          # It is up to the MongoDB server to decide how to report a change.
          # This expectation is based on the current MongoDB server behavior.
          # Alternatively, we could have used a set of possible expectations of which only one
          # must be satisfied, but the unified test format does not support this.
          "updateDescription": {
            "updatedFields": {},
            "removedFields": [],
            "truncatedArrays": [
              {
                "field": "array",
                "newSize": 2
              }
            ]
          }
        }
  - description: "$changeStream must be the first stage in a change stream pipeline sent to the server"
    runOnRequirements:
      - minServerVersion: "3.6"
        topologies: [replicaset]
    operations:
      - name: createChangeStream
        object: *collection0
        arguments:
          pipeline: []
        saveResultAsEntity: &changeStream0 changeStream0
      - name: insertOne
        object: *globalCollection0
        arguments:
          document: {
            "x": 1
          }
      - name: iterateUntilDocumentOrError
        object: *changeStream0
        expectResult: {
          "_id": { "$$exists": true },
          "documentKey": { "$$exists": true },
          "operationType": "insert",
          "ns": {
            "db": *database0,
            "coll": *collection0
          },
          "fullDocument": {
            "_id": { "$$exists": true },
            "x": {
              "$numberInt": "1"
            }
          }
        }
    expectEvents:
      - client: *client0
        eventMatch: prefix
        events:
          - commandStartedEvent:
              command:
                aggregate: *collection0
                cursor: {}
                pipeline: [$changeStream: {}]
