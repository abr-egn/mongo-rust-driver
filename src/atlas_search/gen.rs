//! This file was autogenerated.  Do not manually edit.
use super::*;
#[allow(missing_docs)]
pub struct Autocomplete;
/**The autocomplete operator performs a search for a word or phrase that
contains a sequence of characters from an incomplete input string. The
fields that you intend to query with the autocomplete operator must be
indexed with the autocomplete data type in the collection's index definition.
*/
///
///For more details, see the [autocomplete operator reference](https://www.mongodb.com/docs/atlas/atlas-search/autocomplete/).
pub fn autocomplete(
    path: impl StringOrArray,
    query: impl StringOrArray,
) -> AtlasSearch<Autocomplete> {
    AtlasSearch {
        name: "autocomplete",
        stage: doc! {
            "path" : path.to_bson(), "query" : query.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Autocomplete> {
    #[allow(missing_docs)]
    pub fn token_order(mut self, token_order: TokenOrder) -> Self {
        self.stage.insert("tokenOrder", token_order.name());
        self
    }
    #[allow(missing_docs)]
    pub fn fuzzy(mut self, fuzzy: Document) -> Self {
        self.stage.insert("fuzzy", fuzzy);
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Compound;
/**The compound operator combines two or more operators into a single query.
Each element of a compound query is called a clause, and each clause
consists of one or more sub-queries.
*/
///
///For more details, see the [compound operator reference](https://www.mongodb.com/docs/atlas/atlas-search/compound/).
pub fn compound() -> AtlasSearch<Compound> {
    AtlasSearch {
        name: "compound",
        stage: doc! {},
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Compound> {
    #[allow(missing_docs)]
    pub fn must(mut self, must: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "must",
            must.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn must_not(mut self, must_not: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "mustNot",
            must_not.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn should(mut self, should: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "should",
            should.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn filter(mut self, filter: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "filter",
            filter.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn minimum_should_match(mut self, minimum_should_match: i32) -> Self {
        self.stage
            .insert("minimumShouldMatch", minimum_should_match);
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct EmbeddedDocument;
/**The embeddedDocument operator is similar to $elemMatch operator.
It constrains multiple query predicates to be satisfied from a single
element of an array of embedded documents. embeddedDocument can be used only
for queries over fields of the embeddedDocuments
*/
///
///For more details, see the [embeddedDocument operator reference](https://www.mongodb.com/docs/atlas/atlas-search/embedded-document/).
pub fn embedded_document(
    path: impl StringOrArray,
    operator: impl SearchOperator,
) -> AtlasSearch<EmbeddedDocument> {
    AtlasSearch {
        name: "embeddedDocument",
        stage: doc! {
            "path" : path.to_bson(), "operator" : operator.to_doc(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<EmbeddedDocument> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Equals;
/**The equals operator checks whether a field matches a value you specify.
 * */
///
///For more details, see the [equals operator reference](https://www.mongodb.com/docs/atlas/atlas-search/equals/).
pub fn equals(path: impl StringOrArray, value: impl Into<Bson>) -> AtlasSearch<Equals> {
    AtlasSearch {
        name: "equals",
        stage: doc! {
            "path" : path.to_bson(), "value" : value.into(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Equals> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Exists;
/**The exists operator tests if a path to a specified indexed field name exists in a document.
 * */
///
///For more details, see the [exists operator reference](https://www.mongodb.com/docs/atlas/atlas-search/exists/).
pub fn exists(path: impl StringOrArray) -> AtlasSearch<Exists> {
    AtlasSearch {
        name: "exists",
        stage: doc! {
            "path" : path.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Exists> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Facet;
/**The facet collector groups results by values or ranges in the specified
faceted fields and returns the count for each of those groups.
*/
///
///For more details, see the [facet operator reference](https://www.mongodb.com/docs/atlas/atlas-search/facet/).
pub fn facet(facets: Document) -> AtlasSearch<Facet> {
    AtlasSearch {
        name: "facet",
        stage: doc! {
            "facets" : facets,
        },
        meta: true,
        _t: PhantomData,
    }
}
impl AtlasSearch<Facet> {
    #[allow(missing_docs)]
    pub fn operator(mut self, operator: impl SearchOperator) -> Self {
        self.stage.insert("operator", operator.to_doc());
        self
    }
}
#[allow(missing_docs)]
pub struct Text;
/**The text operator performs a full-text search using the analyzer that you specify in the index configuration.
If you omit an analyzer, the text operator uses the default standard analyzer.
*/
///
///For more details, see the [text operator reference](https://www.mongodb.com/docs/atlas/atlas-search/text/).
pub fn text(path: impl StringOrArray, query: impl StringOrArray) -> AtlasSearch<Text> {
    AtlasSearch {
        name: "text",
        stage: doc! {
            "path" : path.to_bson(), "query" : query.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Text> {
    #[allow(missing_docs)]
    pub fn fuzzy(mut self, fuzzy: Document) -> Self {
        self.stage.insert("fuzzy", fuzzy);
        self
    }
    #[allow(missing_docs)]
    pub fn match_criteria(mut self, match_criteria: MatchCriteria) -> Self {
        self.stage.insert("matchCriteria", match_criteria.name());
        self
    }
    #[allow(missing_docs)]
    pub fn synonyms(mut self, synonyms: impl AsRef<str>) -> Self {
        self.stage.insert("synonyms", synonyms.as_ref());
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
