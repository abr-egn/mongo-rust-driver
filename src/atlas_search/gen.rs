//! This file was autogenerated.  Do not manually edit.
use super::*;
#[allow(missing_docs)]
pub struct Autocomplete;
/**The autocomplete operator performs a search for a word or phrase that
contains a sequence of characters from an incomplete input string. The
fields that you intend to query with the autocomplete operator must be
indexed with the autocomplete data type in the collection's index definition.
*/
///
///For more details, see the [autocomplete operator reference](https://www.mongodb.com/docs/atlas/atlas-search/autocomplete/).
pub fn autocomplete(
    path: impl StringOrArray,
    query: impl StringOrArray,
) -> AtlasSearch<Autocomplete> {
    AtlasSearch {
        name: "autocomplete",
        stage: doc! {
            "path" : path.to_bson(), "query" : query.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Autocomplete> {
    #[allow(missing_docs)]
    pub fn token_order(mut self, token_order: TokenOrder) -> Self {
        self.stage.insert("tokenOrder", token_order.name());
        self
    }
    #[allow(missing_docs)]
    pub fn fuzzy(mut self, fuzzy: Document) -> Self {
        self.stage.insert("fuzzy", fuzzy);
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Compound;
/**The compound operator combines two or more operators into a single query.
Each element of a compound query is called a clause, and each clause
consists of one or more sub-queries.
*/
///
///For more details, see the [compound operator reference](https://www.mongodb.com/docs/atlas/atlas-search/compound/).
pub fn compound() -> AtlasSearch<Compound> {
    AtlasSearch {
        name: "compound",
        stage: doc! {},
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Compound> {
    #[allow(missing_docs)]
    pub fn must(mut self, must: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "must",
            must.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn must_not(mut self, must_not: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "mustNot",
            must_not.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn should(mut self, should: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "should",
            should.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn filter(mut self, filter: impl IntoIterator<Item = impl SearchOperator>) -> Self {
        self.stage.insert(
            "filter",
            filter.into_iter().map(|o| o.to_doc()).collect::<Vec<_>>(),
        );
        self
    }
    #[allow(missing_docs)]
    pub fn minimum_should_match(mut self, minimum_should_match: i32) -> Self {
        self.stage
            .insert("minimumShouldMatch", minimum_should_match);
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct EmbeddedDocument;
/**The embeddedDocument operator is similar to $elemMatch operator.
It constrains multiple query predicates to be satisfied from a single
element of an array of embedded documents. embeddedDocument can be used only
for queries over fields of the embeddedDocuments
*/
///
///For more details, see the [embeddedDocument operator reference](https://www.mongodb.com/docs/atlas/atlas-search/embedded-document/).
pub fn embedded_document(
    path: impl StringOrArray,
    operator: impl SearchOperator,
) -> AtlasSearch<EmbeddedDocument> {
    AtlasSearch {
        name: "embeddedDocument",
        stage: doc! {
            "path" : path.to_bson(), "operator" : operator.to_doc(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<EmbeddedDocument> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Equals;
/**The equals operator checks whether a field matches a value you specify.
 * */
///
///For more details, see the [equals operator reference](https://www.mongodb.com/docs/atlas/atlas-search/equals/).
pub fn equals(path: impl StringOrArray, value: impl Into<Bson>) -> AtlasSearch<Equals> {
    AtlasSearch {
        name: "equals",
        stage: doc! {
            "path" : path.to_bson(), "value" : value.into(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Equals> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Exists;
/**The exists operator tests if a path to a specified indexed field name exists in a document.
 * */
///
///For more details, see the [exists operator reference](https://www.mongodb.com/docs/atlas/atlas-search/exists/).
pub fn exists(path: impl StringOrArray) -> AtlasSearch<Exists> {
    AtlasSearch {
        name: "exists",
        stage: doc! {
            "path" : path.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Exists> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Facet;
/**The facet collector groups results by values or ranges in the specified
faceted fields and returns the count for each of those groups.
*/
///
///For more details, see the [facet operator reference](https://www.mongodb.com/docs/atlas/atlas-search/facet/).
pub fn facet(facets: Document) -> AtlasSearch<Facet> {
    AtlasSearch {
        name: "facet",
        stage: doc! {
            "facets" : facets,
        },
        meta: true,
        _t: PhantomData,
    }
}
impl AtlasSearch<Facet> {
    #[allow(missing_docs)]
    pub fn operator(mut self, operator: impl SearchOperator) -> Self {
        self.stage.insert("operator", operator.to_doc());
        self
    }
}
#[allow(missing_docs)]
pub struct Range;
/**The range operator supports querying and scoring numeric, date, and string values.
You can use this operator to find results that are within a given numeric, date, objectId, or letter (from the English alphabet) range.
*/
///
///For more details, see the [range operator reference](https://www.mongodb.com/docs/atlas/atlas-search/range/).
pub fn range(path: impl StringOrArray) -> AtlasSearch<Range> {
    AtlasSearch {
        name: "range",
        stage: doc! {
            "path" : path.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Range> {
    #[allow(missing_docs)]
    pub fn gt(mut self, gt: impl Into<Bson>) -> Self {
        self.stage.insert("gt", gt.into());
        self
    }
    #[allow(missing_docs)]
    pub fn gte(mut self, gte: impl Into<Bson>) -> Self {
        self.stage.insert("gte", gte.into());
        self
    }
    #[allow(missing_docs)]
    pub fn lt(mut self, lt: impl Into<Bson>) -> Self {
        self.stage.insert("lt", lt.into());
        self
    }
    #[allow(missing_docs)]
    pub fn lte(mut self, lte: impl Into<Bson>) -> Self {
        self.stage.insert("lte", lte.into());
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct GeoShape;
/**The geoShape operator supports querying shapes with a relation to a given
geometry if indexShapes is set to true in the index definition.
*/
///
///For more details, see the [geoShape operator reference](https://www.mongodb.com/docs/atlas/atlas-search/geoShape/).
pub fn geo_shape(
    path: impl StringOrArray,
    relation: Relation,
    geometry: Document,
) -> AtlasSearch<GeoShape> {
    AtlasSearch {
        name: "geoShape",
        stage: doc! {
            "path" : path.to_bson(), "relation" : relation.name(), "geometry" : geometry,
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<GeoShape> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct GeoWithin;
/**The geoWithin operator supports querying geographic points within a given
geometry. Only points are returned, even if indexShapes value is true in
the index definition.
*/
///
///For more details, see the [geoWithin operator reference](https://www.mongodb.com/docs/atlas/atlas-search/geoWithin/).
pub fn geo_within(path: impl StringOrArray) -> AtlasSearch<GeoWithin> {
    AtlasSearch {
        name: "geoWithin",
        stage: doc! {
            "path" : path.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<GeoWithin> {
    #[allow(missing_docs)]
    pub fn geo_box(mut self, geo_box: Document) -> Self {
        self.stage.insert("box", geo_box);
        self
    }
    #[allow(missing_docs)]
    pub fn circle(mut self, circle: Document) -> Self {
        self.stage.insert("circle", circle);
        self
    }
    #[allow(missing_docs)]
    pub fn geometry(mut self, geometry: Document) -> Self {
        self.stage.insert("geometry", geometry);
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct SearchIn;
/**The in operator performs a search for an array of BSON values in a field.
 * */
///
///For more details, see the [in operator reference](https://www.mongodb.com/docs/atlas/atlas-search/in/).
pub fn search_in(path: impl StringOrArray, value: impl Into<Bson>) -> AtlasSearch<SearchIn> {
    AtlasSearch {
        name: "in",
        stage: doc! {
            "path" : path.to_bson(), "value" : value.into(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<SearchIn> {
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
#[allow(missing_docs)]
pub struct Text;
/**The text operator performs a full-text search using the analyzer that you specify in the index configuration.
If you omit an analyzer, the text operator uses the default standard analyzer.
*/
///
///For more details, see the [text operator reference](https://www.mongodb.com/docs/atlas/atlas-search/text/).
pub fn text(path: impl StringOrArray, query: impl StringOrArray) -> AtlasSearch<Text> {
    AtlasSearch {
        name: "text",
        stage: doc! {
            "path" : path.to_bson(), "query" : query.to_bson(),
        },
        meta: false,
        _t: PhantomData,
    }
}
impl AtlasSearch<Text> {
    #[allow(missing_docs)]
    pub fn fuzzy(mut self, fuzzy: Document) -> Self {
        self.stage.insert("fuzzy", fuzzy);
        self
    }
    #[allow(missing_docs)]
    pub fn match_criteria(mut self, match_criteria: MatchCriteria) -> Self {
        self.stage.insert("matchCriteria", match_criteria.name());
        self
    }
    #[allow(missing_docs)]
    pub fn synonyms(mut self, synonyms: impl AsRef<str>) -> Self {
        self.stage.insert("synonyms", synonyms.as_ref());
        self
    }
    #[allow(missing_docs)]
    pub fn score(mut self, score: Document) -> Self {
        self.stage.insert("score", score);
        self
    }
}
